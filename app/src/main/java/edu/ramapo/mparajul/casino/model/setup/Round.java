//****************************************************
//* Name: Manasbi Parajuli
//* Project: Casino
//* Class: CMPS 366-01
//* Date: 11/20/2018
//****************************************************
package edu.ramapo.mparajul.casino.model.setup;

import android.content.Intent;
import android.os.Bundle;
import android.os.Environment;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.Vector;

import edu.ramapo.mparajul.casino.model.players.Computer;
import edu.ramapo.mparajul.casino.model.players.Human;
import edu.ramapo.mparajul.casino.model.players.Player;
import edu.ramapo.mparajul.casino.model.utility.Score;

public class Round {
    private int roundNumber;
    private int numberOfPlayers;
    private int humanIndex;
    private int computerIndex;

    private String lastCapturer;
    private String nextPlayer;

    private boolean isNewGame;
    private boolean roundEnded;

    private Vector<Card> tableCards = new Vector<>();
    private Deck deck = new Deck();
    private HashMap<String, String> roundEndScores = new HashMap<>();
    private Player[] players = new Player[2];

    // ****************************************************************
    // Function Name: Round
    // Purpose: serves as a default constructor for Round class
    // Parameters: none
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public Round()
    {
    }

    // ****************************************************************
    // Function Name: Round
    // Purpose: serves as a default constructor for Round class
    // Parameters: -> nextPlayer, a string. Holds the name of the next player
    //             -> lastCapturer, a string. Holds the last capturer in the game
    //             -> roundNumber, an integer. Holds the current round value
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public Round(String nextPlayer, String lastCapturer, int roundNumber)
    {
        this.nextPlayer = nextPlayer;
        this.lastCapturer = lastCapturer;
        this.roundNumber = roundNumber;
        this.tableCards = new Vector<>();
        this.roundEndScores = new HashMap<>();
        this.roundEnded = false;
        numberOfPlayers = 2;
        isNewGame = false;

        // This will be executed for first round
        // Set the index of the players based on who the next player is
        if (this.nextPlayer.equals("Human")) {
            humanIndex = 0;
            computerIndex = 1;
        }
        if (this.nextPlayer.equals("Computer")) {
            humanIndex = 1;
            computerIndex = 0;
        }

        // This will be executed when a new round starts after previous round ended
        // The player that last captured the cards will go first in next round
        if (this.lastCapturer.equals("Human")) {
            humanIndex = 0;
            computerIndex = 1;
            this.nextPlayer = "Human";
        }
        if (this.lastCapturer.equals("Computer")) {
            humanIndex = 1;
            computerIndex = 0;
            this.nextPlayer = "Computer";
        }

        players[humanIndex] = new Human("Human");
        players[computerIndex] = new Computer("Computer");
        deck = new Deck();
        roundEndScores = new HashMap<>();
    }

    // ****************************************************************
    // Function Name: startGame
    // Purpose: loads the deck generated by the program
    // Parameters: none
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void startGame()
    {
        deck.createShuffledDeck();
        isNewGame = true;
    }

    // ****************************************************************
    // Function Name: dealCardsToPlayer
    // Purpose: deals cards to Human, Computer and places next four cards
    //          on the table
    // Parameters: newRound, the boolean that holds the flag as new round
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void dealCardsToPlayers(boolean newRound)
    {
        int totalCardsToDeal;

        if (newRound) {
            totalCardsToDeal = 12;
        } else {
            totalCardsToDeal = 8;
        }

        // get cards based on whether it is a new or ongoing round and deal accordingly
        for (int i = 0; i < totalCardsToDeal; i++) {
            Card card = deck.dealCard();

            // Deal first four cards to the human player
            if (i < 4) {
                players[humanIndex].addCardsToHand(card);
            }
            // Deal next four cards to the computer
            else if (i < 8) {
                players[computerIndex].addCardsToHand(card);
            }
            // Deal cards on the table if it is a new round
            if (newRound) {
                if (i >= 8 && i < totalCardsToDeal) {
                    tableCards.add(card);
                }
            }
        }
    }

    // ****************************************************************
    // Function Name: makeMove
    // Purpose: makes move for the players based on the current player
    // Parameters: turnPlayer, a string. Holds the current player
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void makeMove(String turnPlayer)
    {
        HashMap<String, Vector<Card>> opponentBuild = new HashMap<>();

        // human player's move
        if (turnPlayer.equals(getHumanPlayerName())) {
            opponentBuild = players[computerIndex].getSingleBuildCard();
            players[humanIndex].play(tableCards, opponentBuild, getComputerPlayerName());

            if (players[humanIndex].isMoveSuccessful()) {
                // set the opponent's build if their build has been modified
                players[computerIndex].setSingleBuildCard(opponentBuild);
            }

            // set the last capturer to this player if any capturing of cards was done in this move
            if (players[humanIndex].hasCapturedCard()) {
                lastCapturer = players[humanIndex].getPlayerName();
            }

            // Set the opponent's build score to 0 if the human player extended computer's build
            if (players[humanIndex].isMakeOpponentBuildScoreEmpty()) {
                players[computerIndex].setFirstBuildScore(0);
            }
        }

        // computer player's move
        else if (turnPlayer.equals(getComputerPlayerName())) {
            opponentBuild = players[humanIndex].getSingleBuildCard();
            players[computerIndex].play(tableCards, opponentBuild, getHumanPlayerName());

            if (players[computerIndex].isMoveSuccessful()) {
                // set the opponent's build if their build has been modified
                players[humanIndex].setSingleBuildCard(opponentBuild);
            }

            // set the last capturer to this player if any capturing of cards was done in this move
            if (players[computerIndex].hasCapturedCard()) {
                lastCapturer = players[computerIndex].getPlayerName();
            }

            // Set the opponent's build score to 0 if the computer extended human's build
            if (players[computerIndex].isMakeOpponentBuildScoreEmpty()) {
                players[humanIndex].setFirstBuildScore(0);
            }
        }
    }

    // ****************************************************************
    // Function Name: setHumanIsMakeOpponentBuildEmpty
    // Purpose: sets human's build to be empty
    // Parameter: flag, a boolean. Holds the flag to make human's build to be empty or not
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void setHumanIsMakeOpponentBuildEmpty(boolean flag)
    {
        players[humanIndex].setMakeOpponentBuildScoreEmpty(flag);
    }

    // ****************************************************************
    // Function Name: setComputerIsMakeOpponentBuildEmpty
    // Purpose: sets computer's build to be empty
    // Parameter: flag, a boolean. Holds the flag to make computer's build to be empty or not
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void setComputerIsMakeOpponentBuildEmpty(boolean flag)
    {
        players[computerIndex].setMakeOpponentBuildScoreEmpty(flag);
    }

    // ****************************************************************
    // Function Name: setSavedPreferences
    // Purpose: loads the values stored in a file
    // Parameter: intent, an Intent. Holds the values of the loaded file
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void setSavedPreferences(Intent intent)
    {
        Bundle bundle = intent.getExtras();
        Vector<Card> cards = new Vector<>();

        if (bundle != null) {
            // set player scores
            players[computerIndex].setTourneyScore(intent.getExtras().getInt("computerScore"));
            players[humanIndex].setTourneyScore(intent.getExtras().getInt("humanScore"));

            // set hand cards
            cards = makeCardFromFile(intent.getExtras().getStringArray("computerHand"));
            players[computerIndex].setCardsOnHand(cards);
            cards = makeCardFromFile(intent.getExtras().getStringArray("humanHand"));
            players[humanIndex].setCardsOnHand(cards);

            // set pile cards
            cards = makeCardFromFile(intent.getExtras().getStringArray("computerPile"));
            players[computerIndex].setCardsOnPile(cards);
            cards = makeCardFromFile(intent.getExtras().getStringArray("humanPile"));
            players[humanIndex].setCardsOnPile(cards);

            // set table cards
            cards = makeCardFromFile(intent.getExtras().getStringArray("tableCards"));
            setTableCards(cards);

            // set deck of cards
            cards = makeCardFromFile(intent.getExtras().getStringArray("deck"));
            setDeck(cards);

            // set build cards
            String owner = intent.getExtras().getString("owner");
            HashMap<String, Vector<Card>> singleBuild = new HashMap<>();
            cards = makeCardFromFile(intent.getExtras().getStringArray("buildCards"));

            // Store the build into the corresponding owner
            if (owner != null) {
                if (owner.equals("Human")) {
                    singleBuild.put(owner, cards);
                    players[humanIndex].setSingleBuildCard(singleBuild);
                    players[humanIndex].setFirstBuildScore(calcBuildScore(cards));
                } else if (owner.equals("Computer")) {
                    singleBuild.put(owner, cards);
                    players[computerIndex].setSingleBuildCard(singleBuild);
                    players[computerIndex].setFirstBuildScore(calcBuildScore(cards));
                }
            }
            // set last capturer
            setLastCapturer(intent.getExtras().getString("lastCapturer"));
        }
    }

    // ****************************************************************
    // Function Name: saveGame
    // Purpose: saves the current game values to a text file
    // Parameter: fileName, a string. the name of the file to be saved to.
    // Return value: a boolean flag that returns whether game was successfully saved or not
    // Assistance Received: none
    // ****************************************************************
    public boolean saveGameToFile(String fileName)
    {
        // the contents of the saved file
        String serializedFile = "";

        StringBuilder stringBuilder = new StringBuilder();

        // Add contents to the file
        serializedFile += "Round: " + getRoundNumber() + "\n\n";

        // Save Computer's game state
        serializedFile += "Computer:\n";
        serializedFile += "Score: " + players[computerIndex].getScore() + "\n";
        serializedFile += "Hand: ";
        for (Card card : players[computerIndex].getCardsOnHand()) {
            stringBuilder.append(card.cardToString()).append(" ");
        }
        serializedFile += stringBuilder.toString() + "\n";

        serializedFile += "Pile: ";
        stringBuilder = new StringBuilder();
        for (Card card : players[computerIndex].getCardsOnPile()) {
            stringBuilder.append(card.cardToString()).append(" ");
        }
        serializedFile += stringBuilder.toString() + "\n\n";

        // Save Human's game state
        serializedFile += "Human:\n";
        serializedFile += "Score: " + players[humanIndex].getScore() + "\n";
        serializedFile += "Hand: ";
        stringBuilder = new StringBuilder();
        for (Card card : players[humanIndex].getCardsOnHand()) {
            stringBuilder.append(card.cardToString()).append(" ");
        }
        serializedFile += stringBuilder.toString() + "\n";

        serializedFile += "Pile: ";
        stringBuilder = new StringBuilder();
        for (Card card : players[humanIndex].getCardsOnPile()) {
            stringBuilder.append(card.cardToString()).append(" ");
        }
        serializedFile += stringBuilder.toString() + "\n\n";

        // Save table
        serializedFile += "Table: " + saveTableCardsToFile();

        // Save build owner
        serializedFile += "Build Owner: " + saveBuildOwnerToFile();

        // Save Last Capturer
        serializedFile += "Last Capturer: " + getLastCapturer() + "\n\n";

        // Save deck
        serializedFile += "Deck: ";
        stringBuilder = new StringBuilder();
        for (Card card : deck.getDeck()) {
            stringBuilder.append(card.cardToString()).append(" ");
        }
        serializedFile += stringBuilder.toString() + "\n\n";

        // save next player
        serializedFile += "Next Player: " + getNextPlayer();

        return generateCasinoOnSD(fileName, serializedFile);
    }

    // ****************************************************************
    // Function Name: generateCasinoOnSD
    // Purpose: saves the file in the devices's internal storage under the folder "Casino"
    // Parameter: -> saveFileName, a string. The name of the file
    //            -> serializedContent, a string.. Holds the contents of the current game state
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    private boolean generateCasinoOnSD(String saveFileName, String serializedContent)
    {
        try {
            File root = new File(Environment.getExternalStorageDirectory(), "Casino");

            // Check if Casino folder exists to save the file
            // If is doesn't, then create the directory
            if (!root.exists()) {
                root.mkdirs();
            }

            File file = new File(root, saveFileName);
            FileWriter writer = new FileWriter(file);

            // Write the contents to the device
            writer.write(serializedContent);
            writer.flush();
            writer.close();
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    // ****************************************************************
    // Function Name: calculateScore
    // Purpose: creates Score object and calls its calculate function to
    //          calculate and then store the scores of human and computer
    // Parameter: none
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void calculateScore()
    {
        // Create a score object by passing the cards on the pile of the players
        Score score = new Score(players[humanIndex].getCardsOnPile(), players[computerIndex].getCardsOnPile());

        // calculate the score of the player using the rules of the game
        score.calculateTotalScore();

        // get the scores of both players and then set their scores by passing their scores.
        int humanScore = score.getPlayerOneScore();
        int computerScore = score.getPlayerTwoScore();
        int humanTotalCards = score.getPlayerOneTotalCards();
        int computerTotalCards = score.getPlayerTwoTotalCards();
        int humanTotalSpades = score.getPlayerOneTotalSpades();
        int computerTotalSpades = score.getPlayerTwoTotalSpades();

        // appends the contents of the players' pile
        StringBuilder humanPile = new StringBuilder();
        StringBuilder computerPile = new StringBuilder();

        for (Card card : players[humanIndex].getCardsOnPile()) {
            humanPile.append(card.cardToString()).append(" ");
        }

        for (Card card : players[computerIndex].getCardsOnPile()) {
            computerPile.append(card.cardToString()).append(" ");
        }

        // Store the scores and piles calculated after the end of round in a Hash Map
        roundEndScores.put("humanPile", humanPile.toString());
        roundEndScores.put("computerPile", computerPile.toString());
        roundEndScores.put("humanTotalCards", String.valueOf(humanTotalCards));
        roundEndScores.put("computerTotalCards", String.valueOf(computerTotalCards));
        roundEndScores.put("humanTotalSpades", String.valueOf(humanTotalSpades));
        roundEndScores.put("computerTotalSpades", String.valueOf(computerTotalSpades));

        players[humanIndex].setScore(humanScore);
        players[computerIndex].setScore(computerScore);
    }

    // ****************************************************************
    // Function Name: removeCardFromTable
    // Purpose: remove the group of cards from table
    // Parameters: cardsToRemove, a vector of cards that need to be
    //                   removed from the table
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void removeCardsFromTable(Vector<Card> cardsToRemove)
    {
        for (Card builtCards : cardsToRemove) {
            tableCards.remove(builtCards);
        }
    }

    // ****************************************************************
    // Function Name: saveTableCardsToFile
    // Purpose: saves the player's single and multiple builds and then the ongoing table cards to file
    // Parameter: none
    // Return value: a string value of builds and loose table value
    // Assistance Received: none
    // ****************************************************************
    private String saveTableCardsToFile()
    {
        StringBuilder stringBuilder = new StringBuilder();

        Vector<Vector<Card>> multipleBuild;
        Vector<Card> singleBuild;

        // Save multiple builds to file
        if (!players[computerIndex].isMultipleBuildEmpty()) {
            stringBuilder.append("[ ");
            multipleBuild = players[computerIndex].getMultipleBuildCard().get(players[computerIndex].getPlayerName());
            saveMultipleBuildToFile(stringBuilder, multipleBuild);
        }

        if (!players[humanIndex].isMultipleBuildEmpty()) {
            stringBuilder.append("[ ");
            multipleBuild = players[humanIndex].getMultipleBuildCard().get(players[humanIndex].getPlayerName());
            saveMultipleBuildToFile(stringBuilder, multipleBuild);
        }

        // Save single builds to file
        if (!players[computerIndex].isSingleBuildEmpty()) {
            stringBuilder.append("[ ");
            singleBuild = players[computerIndex].getSingleBuildCard().get(players[computerIndex].getPlayerName());
            saveSingleBuildToFile(stringBuilder, singleBuild);
        }

        if (!players[humanIndex].isSingleBuildEmpty()) {
            stringBuilder.append("[ ");
            singleBuild = players[humanIndex].getSingleBuildCard().get(players[humanIndex].getPlayerName());
            saveSingleBuildToFile(stringBuilder, singleBuild);
        }

        // Save loose table cards to file
        for (Card card : tableCards) {
            stringBuilder.append(card.cardToString()).append(" ");
        }
        stringBuilder.append("\n\n");

        return stringBuilder.toString();
    }

    // ****************************************************************
    // Function Name: saveBuildOwnerToFile
    // Purpose: saves the build owner to file
    // Parameter: none
    // Return value: a string object with builds followed by their owner's names
    // Assistance Received: none
    // ****************************************************************
    private String saveBuildOwnerToFile()
    {
        StringBuilder stringBuilder = new StringBuilder();

        Vector<Vector<Card>> multipleBuild;
        Vector<Card> singleBuild;

        if (!players[computerIndex].isMultipleBuildEmpty()) {
            stringBuilder.append("[ ");
            multipleBuild = players[computerIndex].getMultipleBuildCard().get(players[computerIndex].getPlayerName());
            saveMultipleBuildToFile(stringBuilder, multipleBuild);
            stringBuilder.append(players[computerIndex].getPlayerName()).append(" ");
        }

        if (!players[humanIndex].isMultipleBuildEmpty()) {
            stringBuilder.append("[ ");
            multipleBuild = players[humanIndex].getMultipleBuildCard().get(players[humanIndex].getPlayerName());
            saveMultipleBuildToFile(stringBuilder, multipleBuild);
            stringBuilder.append(players[humanIndex].getPlayerName()).append(" ");
        }

        // Save single builds to file
        if (!players[computerIndex].isSingleBuildEmpty()) {
            stringBuilder.append("[ ");
            singleBuild = players[computerIndex].getSingleBuildCard().get(players[computerIndex].getPlayerName());
            saveSingleBuildToFile(stringBuilder, singleBuild);
            stringBuilder.append(players[computerIndex].getPlayerName()).append(" ");
        }

        if (!players[humanIndex].isSingleBuildEmpty()) {
            stringBuilder.append("[ ");
            singleBuild = players[humanIndex].getSingleBuildCard().get(players[humanIndex].getPlayerName());
            saveSingleBuildToFile(stringBuilder, singleBuild);
            stringBuilder.append(players[humanIndex].getPlayerName()).append(" ");
        }
        stringBuilder.append("\n\n");
        return stringBuilder.toString();
    }

    // ****************************************************************
    // Function Name: saveSingleBuildToFile
    // Purpose: saves the player's single build to a text file
    // Parameter: saveToFile -> StringBuilder object. Holds the object to append string of builds
    //            singleBuild -> vector of Cards. Holds the player's single build
    //                           to be saved to a file
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    private void saveSingleBuildToFile(StringBuilder stringBuilder, Vector<Card> singleBuild)
    {
        stringBuilder.append("[");
        for (Card card : singleBuild) {
            stringBuilder.append(card.cardToString()).append(" ");
        }
        stringBuilder.append("] ");
    }

    // ****************************************************************
    // Function Name: saveMultipleBuildToFile
    // Purpose: saves the player's multiple build to a text file
    // Parameter: stringBuilder -> StringBuilder object. Holds the object to append string of builds
    //            multipleBuild -> vector of vector of Cards. Holds the player's multibuild to be
    // saved to a file
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    private void saveMultipleBuildToFile(StringBuilder stringBuilder, Vector<Vector<Card>> multipleBuild)
    {
        for (Vector<Card> build : multipleBuild) {
            stringBuilder.append("[");
            for (Card card : build) {
                stringBuilder.append(card.cardToString()).append(" ");
            }
            stringBuilder.append("] ");
        }
        stringBuilder.append("] ");
    }

    // ****************************************************************
    // Function Name: makeCardFromFile
    // Purpose: transforms the string of cards into vector of Card objects
    // Parameters: -> cards, array of string. The array of strings that need to be
    //                      converted into Card objects
    // Return value: vector of card objects.
    // Assistance Received: none
    // ****************************************************************
    private Vector<Card> makeCardFromFile(String[] cards)
    {
        Vector<Card> cardList = new Vector<>();

        // Loop through the string and make it a card object
        // Then return cards as vector of cards
        for (String cardStr : cards) {
            if (cardStr.length() == 2) {
                cardList.add(stringToCard(cardStr));
            }
        }
        return cardList;
    }

    // ****************************************************************
    // Function Name: getHelp
    // Purpose: gets the help explanation based on the computer's strategy
    // Parameters: none
    // Return value: a string containing the possible move explanation for the human player
    // Assistance Received: none
    // ****************************************************************
    public String getHelp()
    {
        // Create a computer object and store human's current game values
        Computer humanHelp = new Computer(players[humanIndex].getPlayerName());
        humanHelp.setCardsOnHand(players[humanIndex].getCardsOnHand());
        humanHelp.setCardsOnPile(players[humanIndex].getCardsOnPile());
        humanHelp.setSingleBuildCard(players[humanIndex].getSingleBuildCard());
        humanHelp.setMultipleBuildCard(players[humanIndex].getMultipleBuildCard());
        humanHelp.setHelpRequested(true);
        humanHelp.setFirstBuildScore(players[humanIndex].getFirstBuildScore());

        HashMap<String, Vector<Card>> opponentBuild = players[computerIndex].getSingleBuildCard();

        Vector<Card> tempTableCards = new Vector<>();
        if (getTableCards() != null) {
            tempTableCards = (Vector<Card>) getTableCards().clone();
        }

        // User computer's game play strategy to find the best possible move
        humanHelp.play(tempTableCards, opponentBuild, getComputerPlayerName());
        return humanHelp.getHelpExplanation();
    }

    // ****************************************************************
    // Function Name: cardScore
    // Purpose: calculate the numerical equivalent of a card
    // Parameters: card, a Card object
    // Return value: integer value, the numerical equivalent of a card
    // Assistance Received: none
    // ****************************************************************
    private int cardScore(Card card)
    {
        String face = card.getFace();

        if (face.equals("A")) { return 1; }
        else if (face.equals("2")) { return 2; }
        else if (face.equals("3")) { return 3; }
        else if (face.equals("4")) { return 4; }
        else if (face.equals("5")) { return 5; }
        else if (face.equals("6")) { return 6; }
        else if (face.equals("7")) { return 7; }
        else if (face.equals("8")) { return 8; }
        else if (face.equals("9")) { return 9; }
        else if (face.equals("X")) { return 10; }
        else if (face.equals("J")) { return 11; }
        else if (face.equals("Q")) { return 12; }
        else { return 13; }
    }

    // ****************************************************************
    // Function Name: calcBuildScore
    // Purpose: calculate the score of the build
    // Parameters: buildCards, a vector of strings. It holds the build combination.
    // Return value: integer value, the score of the build
    // Assistance Received: none
    // ****************************************************************
    private int calcBuildScore(Vector<Card> buildCards)
    {
        int score = 0;
        // Go through the build and add the score of each of the cards
        for (Card cards : buildCards) {
            score += cardScore(cards);
        }
        return score;
    }

    // ****************************************************************
    // Function Name: getRoundNumber
    // Purpose: gets the current round number
    // Parameter: none
    // Return value: the current round, an integer value
    // Assistance Received: none
    // ****************************************************************
    public int getRoundNumber()
    {
        return roundNumber;
    }

    // ****************************************************************
    // Function Name: getLastCapturer
    // Purpose: gets the last capturer player in the game
    // Parameters: none
    // Return value: identifier of the last capturer player, a string.
    // Assistance Received: none
    // ****************************************************************
    public String getLastCapturer()
    {
        return lastCapturer;
    }

    // ****************************************************************
    // Function Name: setLastCapturer
    // Purpose: sets the last capturer in the game
    // Parameters: capturer, a string. Holds the name of the last capturer in the game
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void setLastCapturer(String lastCapturer)
    {
        this.lastCapturer = lastCapturer;
    }

    // ****************************************************************
    // Function Name: getNextPlayer
    // Purpose: gets the next player in the game
    // Parameters: none
    // Return value: identifier of the next player, a string.
    // Assistance Received: none
    // ****************************************************************
    public String getNextPlayer()
    {
        return nextPlayer;
    }

    // ****************************************************************
    // Function Name: setNextPlayer
    // Purpose: sets the next player in the game
    // Parameters: next, a string. Holds the name of the next player in the game
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void setNextPlayer(String nextPlayer)
    {
        this.nextPlayer = nextPlayer;
    }

    // ****************************************************************
    // Function Name: setDeck
    // Purpose: sets the deck in the game
    // Parameters: tempDeck, a vector of cards. Hold the new deck for the game
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void setDeck(Vector<Card> tempDeck)
    {
        deck.setDeck(tempDeck);
    }

    // ****************************************************************
    // Function Name: getDeck
    // Purpose: gets the deck in the game
    // Parameters: none
    // Return value: a vector of cards. Holds the current deck
    // Assistance Received: none
    // ****************************************************************
    public Vector<Card> getDeck()
    {
        return deck.getDeck();
    }

    // ****************************************************************
    // Function Name: isDeckEmpty
    // Purpose: returns whether the current deck is empty or not
    // Parameters: none
    // Return value: flag that identifies whether the current deck is empty or not
    // Assistance Received: none
    // ****************************************************************
    public boolean isDeckEmpty()
    {
        return deck.isDeckEmpty();
    }

    // ****************************************************************
    // Function Name: isNewGame
    // Purpose: identifies whether it is a new game or not
    // Parameters: none
    // Return value: flag that identifies whether the game started new or not
    // Assistance Received: none
    // ****************************************************************
    public boolean isNewGame()
    {
        return isNewGame;
    }

    // ****************************************************************
    // Function Name: setNewGame
    // Purpose: sets the flag to identify whether it is a new game or not
    // Parameters: newGame, a boolean.
    // Return value: flag that identifies whether the game started new or not
    // Assistance Received: none
    // ****************************************************************
    public void setNewGame(boolean newGame)
    {
        isNewGame = newGame;
    }

    // ****************************************************************
    // Function Name: getTableCards
    // Purpose: gets the current cards in the table
    // Parameters: none
    // Return value: a vector of table cards.
    // Assistance Received: none
    // ****************************************************************
    public Vector<Card> getTableCards()
    {
        return tableCards;
    }

    // ****************************************************************
    // Function Name: setTableCards
    // Purpose: sets the current cards in the table
    // Parameters: cards, a vector of table cards
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void setTableCards(Vector<Card> tableCards)
    {
        this.tableCards = tableCards;
    }

    // ****************************************************************
    // Function Name: setHumanCardsOnPile
    // Purpose: sets human's cards on pile
    // Parameters: cards, a vector of pile of cards
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void setHumanCardsOnPile(Vector<Card> cards)
    {
        for (Card card : cards) {
            players[humanIndex].addCardsToPile(card);
        }
    }

    // ****************************************************************
    // Function Name: setComputerCardsOnPile
    // Purpose: sets computer's cards on pile
    // Parameters: cards, a vector of pile of cards
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void setComputerCardsOnPile(Vector<Card> cards)
    {
        for (Card card : cards) {
            players[computerIndex].addCardsToPile(card);
        }
    }

    // ****************************************************************
    // Function Name: getHumanCardsOnHand
    // Purpose: gets human's cards on hand
    // Parameters: none
    // Return value: a vector of cards representing human's cards on hand
    // Assistance Received: none
    // ****************************************************************
    public Vector<Card> getHumanCardsOnHand()
    {
        return players[humanIndex].getCardsOnHand();
    }

    // ****************************************************************
    // Function Name: getComputerCardsOnHand
    // Purpose: gets computer's cards on hand
    // Parameters: none
    // Return value: a vector of cards representing computer's cards on hand
    // Assistance Received: none
    // ****************************************************************
    public Vector<Card> getComputerCardsOnHand()
    {
        return players[computerIndex].getCardsOnHand();
    }

    // ****************************************************************
    // Function Name: getHumanCardsOnPile
    // Purpose: gets human's cards on pile
    // Parameters: cards, a vector of pile of cards
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public Vector<Card> getHumanCardsOnPile()
    {
        return players[humanIndex].getCardsOnPile();
    }

    // ****************************************************************
    // Function Name: getComputerCardsOnPile
    // Purpose: gets computer's cards on pile
    // Parameters: cards, a vector of pile of cards
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public Vector<Card> getComputerCardsOnPile()
    {
        return players[computerIndex].getCardsOnPile();
    }

    // ****************************************************************
    // Function Name: getHumanTourneyScore
    // Purpose: gets the human player's score of the tournament
    // Parameters: none
    // Return value: humanTournamentScore, an integer. Holds the human's tourney score
    // Assistance Received: none
    // ****************************************************************
    public int getHumanTourneyScore()
    {
        return players[humanIndex].getTourneyScore();
    }

    // ****************************************************************
    // Function Name: getComputerTournamentScore
    // Purpose: gets the computer's score of the tournament
    // Parameters: none
    // Return value: the computer's tourney score
    // Assistance Received: none
    // ****************************************************************
    public int getComputerTourneyScore()
    {
        return players[computerIndex].getTourneyScore();
    }

    // ****************************************************************
    // Function Name: getHumanRoundScore
    // Purpose: gets the human player's round score
    // Parameters: none
    // Return value: the human's round score
    // Assistance Received: none
    // ****************************************************************
    public int getHumanRoundScore()
    {
        return players[humanIndex].getScore();
    }

    // ****************************************************************
    // Function Name: getComputerRoundScore
    // Purpose: gets the computer player's round score
    // Parameters: none
    // Return value: the computer's round score
    // Assistance Received: none
    // ****************************************************************
    public int getComputerRoundScore()
    {
        return players[computerIndex].getScore();
    }

    // ****************************************************************
    // Function Name: getHumanPlayerName
    // Purpose: gets the human player's name
    // Parameters: none
    // Return value: the name of the human player
    // Assistance Received: none
    // ****************************************************************
    public String getHumanPlayerName()
    {
        return players[humanIndex].getPlayerName();
    }

    // ****************************************************************
    // Function Name: getComputerPlayerName
    // Purpose: gets the computer player's name
    // Parameters: none
    // Return value: the name of the computer player
    // Assistance Received: none
    // ****************************************************************
    public String getComputerPlayerName() { return players[computerIndex].getPlayerName(); }

    // ****************************************************************
    // Function Name: setMoveActionIdentifier
    // Purpose: sets the name of the move that the player is trying to make
    // Parameter: moveActionIdentifier, a string. Holds the player's action name
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void setMoveActionIdentifier(String moveActionIdentifier)
    {
        players[humanIndex].setMoveActionIdentifier(moveActionIdentifier);
    }

    // ****************************************************************
    // Function Name: setClickedTableCards
    // Purpose: saves the table cards clicked by the player
    // Parameter: clickedTableCards. Holds the table cards clicked by the human player
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void setClickedTableCards(Vector<String> clickedTableCards)
    {
        Vector<Card> temp = new Vector<>();
        for (String cardStr : clickedTableCards) {
            temp.add(stringToCard(cardStr));
        }
        players[humanIndex].setClickedTableCards(temp);
    }

    // ****************************************************************
    // Function Name: setClickedBuildCards
    // Purpose: saves the build cards clicked by the player
    // Parameter: clickedBuildCards. Holds the build cards clicked by the human player
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void setClickedBuildCards(Vector<String> clickedBuildCards)
    {
        Vector<Card> temp = new Vector<>();
        for (String cardStr : clickedBuildCards) {
            temp.add(stringToCard(cardStr));
        }
        players[humanIndex].setClickedBuildCards(temp);
    }

    // ****************************************************************
    // Function Name: setClickedHandCards
    // Purpose: saves the hand card clicked by the human player
    // Parameter: clickedHandCard. Holds the hand card clicked by the human player
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void setClickedHandCard(String handCard)
    {
        players[humanIndex].setClickedHandCard(stringToCard(handCard));
    }

    // ****************************************************************
    // Function Name: stringToCard
    // Purpose: converts a string into a Card object
    // Parameter: cardStr, a string. Holds the string representation of a card
    // Return value: a Card object.
    // Assistance Received: none
    // ****************************************************************
    private Card stringToCard(String cardStr)
    {
        return (new Card(Character.toString(cardStr.charAt(0)),
                Character.toString(cardStr.charAt(1))));
    }

    // ****************************************************************
    // Function Name: getHumanIsMoveSuccessful
    // Purpose: returns whether the human made a successful move in the current turn
    // Parameter: none
    // Return value: a boolean based on whether the human made a successful move
    // Assistance Received: none
    // ****************************************************************
    public boolean getHumanIsMoveSuccessful()
    {
        return players[humanIndex].isMoveSuccessful();
    }

    // ****************************************************************
    // Function Name: getComputerIsMoveSuccessful
    // Purpose: returns whether the computer made a successful move in the current turn
    // Parameter: none
    // Return value: a boolean based on whether the computer made a successful move
    // Assistance Received: none
    // ****************************************************************
    public boolean getComputerIsMoveSuccessful()
    {
        return (players[computerIndex].isMoveSuccessful());
    }

    // ****************************************************************
    // Function Name: setComputerIsMoveSuccessful
    // Purpose: sets whether the computer made a successful move in the current turn
    // Parameter: flag, a boolean. Holds whether the computer made a successful move
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void setComputerIsMoveSuccessful(boolean flag)
    {
        players[computerIndex].setMoveSuccessful(flag);
    }

    // ****************************************************************
    // Function Name: setHumanIsMoveSuccessful
    // Purpose: sets whether the human made a successful move in the current turn
    // Parameter: flag, a boolean. Holds whether the human made a successful move
    // Return value: none
    // Assistance Received: none
    // ****************************************************************
    public void setHumanIsMoveSuccessful(boolean flag)
    {
        players[humanIndex].setMoveSuccessful(flag);
    }

    // ****************************************************************
    // Function Name: getHumanMoveExplanation
    // Purpose: gets the explanation for the move that human makes
    // Parameters: none
    // Return value: a string that stores the explanation of the move
    // Assistance Received: none
    // ****************************************************************
    public String getHumanMoveExplanation()
    {
        return players[humanIndex].getMoveExplanation();
    }

    // ****************************************************************
    // Function Name: getComputerMoveExplanation
    // Purpose: gets the explanation for the move that the computer makes
    // Parameters: none
    // Return value: a string that stores the explanation of the move
    // Assistance Received: none
    // ****************************************************************
    public String getComputerMoveExplanation()
    {
        return players[computerIndex].getMoveExplanation();
    }

    // ****************************************************************
    // Function Name: isHumanSingleBuildEmpty
    // Purpose: returns whether the human player has a single build
    // Parameter: none
    // Return value: a boolean based on whether the human player has a single build or not
    // Assistance Received: none
    // ****************************************************************
    public boolean isHumanSingleBuildEmpty()
    {
        return players[humanIndex].isSingleBuildEmpty();
    }

    // ****************************************************************
    // Function Name: isComputerSingleBuildEmpty
    // Purpose: returns whether the computer has a single build
    // Parameter: none
    // Return value: a boolean based on whether the computer has a single build or not
    // Assistance Received: none
    // ****************************************************************
    public boolean isComputerSingleBuildEmpty()
    {
        return players[computerIndex].isSingleBuildEmpty();
    }

    // ****************************************************************
    // Function Name: isHumanMultipleBuildEmpty
    // Purpose: returns whether the human player has a multiple build
    // Parameter: none
    // Return value: a boolean based on whether the human player has a multiple build or not
    // Assistance Received: none
    // ****************************************************************
    public boolean isHumanMultipleBuildEmpty()
    {
        return players[humanIndex].isMultipleBuildEmpty();
    }

    // ****************************************************************
    // Function Name: isComputerMultipleBuildEmpty
    // Purpose: returns whether the computer has a multiple build
    // Parameter: none
    // Return value: a boolean based on whether the computer has a multiple build or not
    // Assistance Received: none
    // ****************************************************************
    public boolean isComputerMultipleBuildEmpty()
    {
        return players[computerIndex].isMultipleBuildEmpty();
    }

    // ****************************************************************
    // Function Name: getHumanSingleBuildCard
    // Purpose: gets the successful single build of the human player
    // Parameter: none
    // Return value: a Hash Map of owner as string and single build as vector of cards
    // Assistance Received: none
    // ****************************************************************
    public HashMap<String, Vector<Card>> getHumanSingleBuildCard()
    {
        return players[humanIndex].getSingleBuildCard();
    }

    // ****************************************************************
    // Function Name: getComputerSingleBuildCard
    // Purpose: gets the successful single build of the computer player
    // Parameter: none
    // Return value: a Hash Map of owner as string and single build as vector of cards
    // Assistance Received: none
    // ****************************************************************
    public HashMap<String, Vector<Card>> getComputerSingleBuildCard()
    {
        return players[computerIndex].getSingleBuildCard();
    }

    // ****************************************************************
    // Function Name: getHumanMultipleBuildCard
    // Purpose: gets the successful multiple build of the player
    // Parameter: none
    // Return value: a Hash Map of owner as string and multiple builds as
    //                  vector of vector of cards
    // Assistance Received: none
    // ****************************************************************
    public HashMap<String, Vector<Vector<Card>>> getHumanMultipleBuildCard()
    {
        return players[humanIndex].getMultipleBuildCard();
    }

    // ****************************************************************
    // Function Name: getComputerMultipleBuildCard
    // Purpose: gets the successful multiple build of the computer player
    // Parameter: none
    // Return value: a Hash Map of owner as string and multiple builds as
    //                  vector of vector of cards
    // Assistance Received: none
    // ****************************************************************
    public HashMap<String, Vector<Vector<Card>>> getComputerMultipleBuildCard()
    {
        return players[computerIndex].getMultipleBuildCard();
    }

    // ****************************************************************
    // Function Name: getRoundEndScores
    // Purpose: gets the last rounds scores, total cards, total spades of the players
    // Parameters: none
    // Return value: a hash map of player's names corresponding to their card (Spade, Ace) scores
    // Assistance Received: none
    // ****************************************************************
    public HashMap<String, String> getRoundEndScores()
    {
        return roundEndScores;
    }
}
